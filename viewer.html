<!DOCTYPE html>
<meta charset="utf-8">

<link href="ext/html/nvd3/nv.d3.css" rel="stylesheet" type="text/css">
<script src="ext/html/nvd3/lib/d3.v3.js"></script>
<script src="ext/html/nvd3/nv.d3.min.js"></script>

<style>
body {
  overflow-y:scroll;
}

body {
   font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
      font-weight: 300;
}

text {
  font: 12px sans-serif;
}

svg {
  display: block;
}

.chart svg {
  height: 300px;

}
.chart {
  min-width: 200px;
  max-width: 600px;
  margin-top: 10px;
  margin-left: 20px;
}

#pup {
  position:absolute;
  z-index:200; /* aaaalways on top*/
  padding: 3px;
  margin-left: 10px;
  margin-top: 5px;
  width: 250px;
  border: 1px solid black;
  background-color: #777;
  color: white;
  font-size: 0.95em;
}
</style>
<body>

<table width="100%"><tr valign="top"><td>
<h1>Antonie 0.0 Big View</h1>
</td><td align="right"><img align="right"
src="http://ds9a.nl/antonie/logo.png"/></td></tr></table>
<p>
Antonie is <a href="https://github.com/beaumontlab/antonie">open source
software</a>, developed at the <a
href="http://bertusbeaumontlab.tudelft.nl/">Beaumont lab</a> at <a
href="http://www.tudelft.nl">TU Delft</a>. If you've benefited from our
work, please cite xyz.
</p>
<p>

<form onSubmit="return UpdateTable();">
<table border="0" cellpadding="4">
<tr><td>NumDiff Filter</td><td><input id="numDiff" value="4" onChange="return UpdateTable();"></input></td></tr>
<!-- <tr><td>Percentage Filter</td><td><input id="percLimit" value="0" onChange="return UpdateTable();"></input></td></tr>
-->
<tr><td>Genes only</td><td><input id="geneFilter" type="checkbox" value="1" onChange="return UpdateTable();"></input></td></tr>
<tr><td>Non-synonymous only</td><td><input id="nonsynFilter" type="checkbox" value="1" onChange="return UpdateTable();"></input></td></tr>
<tr><td>Inserts only</td><td><input id="insertsOnly" type="checkbox" value="0" onChange="return UpdateTable();"></input></td></tr>
<tr><td>Deletes only</td><td><input id="deletesOnly" type="checkbox" value="0" onChange="return UpdateTable();"></input></td></tr>
<tr><td>Remove universal</td><td><input id="nonuniversalFilter" type="checkbox" value="1" onChange="return UpdateTable();"></input></td></tr>
</table>
</form>
</p>
<div id="log"></div>
<p></p>

<table id="toctable" border="1" cellpadding="4">
<thead></thead>
<tbody></tbody>
<!-- <tr><th>Type</th><th>Locus</th><th>Reference</th><th>Var
count</th><th>Annotation(s)</th></tr> -->
</table>
<script type="text/javascript" src="ext/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="ext/nhpup_1.1.js"></script>
<script>
var loci={};
</script>

<script src="loci.js"></script>
<script>

function transform(attrName) {
	d3.select("#toctable tbody").selectAll("tr").remove();

	// set headers
	var th = d3.select("#toctable thead").selectAll("th")
        	    .data(jsonToArray(loci["A12"][0]))
	            .enter().append("th")
	            .attr("onclick", function (d, i) { console.log("sort?"); return "transform('" + d[0] + "');";})
	            .text(function(d) { return d[0]; })

	// Make rows
	    var tr = d3.select("#toctable tbody").selectAll("tr")
        	        .data(loci["A12"])
                	.enter().append("tr")
	                .sort(function (a, b) { return a == null || b == null ? 0 : stringCompare(a[attrName], b[attrName]); })

	// and tell the cells how to fill themselves
	    var td = tr.selectAll("#toctable td")
        	        .data(function(d) { return jsonToArray(d); })
                	.enter().append("td")
	                .attr("onclick", function (d, i) {
	                	return "transform('" + d[0] + "');";})
	                .text(function(d) { return d[1]; });
}

function jsonKeyValueToArray(k, v) {return [k, v];}
 
function jsonToArray(json) {
	var ret = new Array();
        var key;
        for (key in json) {
	        if (json.hasOwnProperty(key)) {
        		ret.push(jsonKeyValueToArray(key,
			        json[key]));
	        }
        }
        return ret;
};

function stringCompare(a, b) {
    return a > b ? 1 : a == b ? 0 : -1;
//    a = a.toLowerCase();
//    b = b.toLowerCase();
//    return a > b ? 1 : a == b ? 0 : -1;
}
            
// transform('locus');


function makeSNPStat()
{
	var ret={};
	ret.counts=0;
	ret.present=[];
	return ret;
}

function UpdateTable()
{
  var numpools=0, numSNPs=0, filteredSNPs=0, nonGene=0;
  var snps={};
  var numDiffLimit = document.getElementById("numDiff").value;
  var geneFilter = document.getElementById("geneFilter").checked;
  var nonsynFilter = document.getElementById("nonsynFilter").checked;
  var nonuniversalFilter = document.getElementById("nonuniversalFilter").checked;
  var deletesOnly = document.getElementById("deletesOnly").checked;
  var insertsOnly = document.getElementById("insertsOnly").checked;
  // console.log("The gene filter "+geneFilter);
  
  $.each(loci, function(pool, poollocus) {
//  	console.log("Pool: "+pool);
	numpools++;
	numSNPs+= poollocus.length;
	$.each(poollocus, function(pos, locus) { 
		if(geneFilter && !locus.gene) {
			nonGene++;
			return;
		}
		if(snps[locus.locus] == undefined) {
			snps[locus.locus]=makeSNPStat();
			snps[locus.locus].description = decodeURIComponent(locus.annotation);
		}
			
		snps[locus.locus].count++;
		snps[locus.locus].present.push([pool, locus]);
	});
  });

  var distinct=0;
  $.each(snps, function() {
 	distinct++;
  });

 
  var table="<table><tr><th>Locus</th><th>Description</th>";
  for(pool in loci) {
	table+=("<th>"+pool+"</th>");
  }
  var realCount=0;
  $.each(snps, function(locus, snp) {
	row="<tr><td>"+locus+"</td><td><small>"+snp.description+"</small></td>";
	var real=false;
	var totfound=false;
	var universal=snp.present.length > 0;
	var totCount=0;	
	for(pool in loci) {
		var found=false;

		for(pos in snp.present) {
			if(snp.present[pos][0]==pool) {
				var aminoReport = snp.present[pos][1].aminoReport;				
				
				var mouseOver="onmouseover='nhpup.popup(\"";
				mouseOver+= "Numdiff: "+snp.present[pos][1].numDiff;
				mouseOver+= ", ";
				if(snp.present[pos][1].xCount) 
					mouseOver += snp.present[pos][1].xCount+" deletes, ";
				if(snp.present[pos][1].insertReport != "") {
					mouseOver += "Inserts: "+snp.present[pos][1].insertReport+", ";
				}
				var totPresent=snp.present[pos][1].numDiff + snp.present[pos][1].depth;
				mouseOver+=(100.0*snp.present[pos][1].numDiff/totPresent).toFixed(2);
				mouseOver+= "&percnt;, depth: " + totPresent;
				mouseOver +=", "+aminoReport;
				mouseOver+="\");'";
				
				if(nonsynFilter) {
					var re=/([A-Z][a-z ]+) -> ([A-Z][a-z ]+) $/;
					var result = re.exec(aminoReport);
	//				console.log(aminoReport +": "+result);
					if(result != null && result[1]==result[2]) {
//						console.log("Neutral:'"+result[1]+"' '"+result[2]+"'");
						continue;
					}
				}
				if(deletesOnly && snp.present[pos][1].xCount == 0) 
					continue;
				if(insertsOnly && snp.present[pos][1].insertReport=='')
					continue;
				totCount+=snp.present[pos][1].numDiff;				
				if(snp.present[pos][1].numDiff < numDiffLimit) 
					row+='<td '+mouseOver+'><font	color="#bbbbbb">'+pool+'</font></td>';
				else if(snp.present[pos][1].numDiff > 10) {
					row+='<td '+mouseOver+'><b>'+pool+'</b></td>';	
					real=1;
				}				
				else {
					row+="<td "+mouseOver+">"+pool+"</td>";
					real=1;
				}	
				found=true;
				break;
			}
		}
		if(!found) {
			row+="<td></td>";
			universal=false;
		}
	}
	
	row+="</tr>";
	if((real || totCount > 3*numDiffLimit) && (!nonuniversalFilter || !universal)) {
		table+=row;
		realCount++;
	}
  });

  table+=("</table>");
  d3.select("#toctable").html(table);
  
  var resp = "There are "+numpools+ " pools, "+numSNPs+" candidate SNPs, "
  resp += nonGene + " non-genes, "+realCount+" distinct left";
  d3.select("#log").text(resp);
  
  return false;
}
UpdateTable();
</script>
